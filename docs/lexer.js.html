

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      lexer.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      Braintree SDK Client Reference
    </h3>

    <h3>Classes</h3><ul><li id="Array-nav"><a href="Array.html">Array</a></li><li id="Assign-nav"><a href="Assign.html">Assign</a></li><li id="AST-nav"><a href="AST.html">AST</a><ul class='methods'><li data-type="method" id="AST-prepare-nav"><a href="AST.html#prepare">prepare</a></li><li data-type="method" id="AST-resolvePrecedence-nav"><a href="AST.html#resolvePrecedence">resolvePrecedence</a></li></ul></li><li id="Bin-nav"><a href="Bin.html">Bin</a></li><li id="Block-nav"><a href="Block.html">Block</a></li><li id="Boolean-nav"><a href="Boolean.html">Boolean</a></li><li id="Break-nav"><a href="Break.html">Break</a></li><li id="Call-nav"><a href="Call.html">Call</a></li><li id="Case-nav"><a href="Case.html">Case</a></li><li id="Cast-nav"><a href="Cast.html">Cast</a></li><li id="Catch-nav"><a href="Catch.html">Catch</a></li><li id="Class-nav"><a href="Class.html">Class</a><ul class='methods'><li data-type="method" id="Class-parseFlags-nav"><a href="Class.html#parseFlags">parseFlags</a></li></ul></li><li id="ClassConstant-nav"><a href="ClassConstant.html">ClassConstant</a><ul class='methods'><li data-type="method" id="ClassConstant-parseFlags-nav"><a href="ClassConstant.html#parseFlags">parseFlags</a></li></ul></li><li id="Clone-nav"><a href="Clone.html">Clone</a></li><li id="Closure-nav"><a href="Closure.html">Closure</a></li><li id="Comment-nav"><a href="Comment.html">Comment</a></li><li id="CommentBlock-nav"><a href="CommentBlock.html">CommentBlock</a></li><li id="CommentLine-nav"><a href="CommentLine.html">CommentLine</a></li><li id="Constant-nav"><a href="Constant.html">Constant</a><ul class='methods'><li data-type="method" id="Constant-parseFlags-nav"><a href="Constant.html#parseFlags">parseFlags</a></li></ul></li><li id="ConstRef-nav"><a href="ConstRef.html">ConstRef</a></li><li id="Continue-nav"><a href="Continue.html">Continue</a></li><li id="Declaration-nav"><a href="Declaration.html">Declaration</a><ul class='methods'><li data-type="method" id="Declaration-parseFlags-nav"><a href="Declaration.html#parseFlags">parseFlags</a></li></ul></li><li id="Declare-nav"><a href="Declare.html">Declare</a></li><li id="Do-nav"><a href="Do.html">Do</a></li><li id="Echo-nav"><a href="Echo.html">Echo</a></li><li id="Empty-nav"><a href="Empty.html">Empty</a></li><li id="Encapsed-nav"><a href="Encapsed.html">Encapsed</a></li><li id="engine-nav"><a href="engine.html">engine</a><ul class='methods'><li data-type="method" id="engine-parseCode-nav"><a href="engine.html#parseCode">parseCode</a></li><li data-type="method" id="engine-parseEval-nav"><a href="engine.html#parseEval">parseEval</a></li><li data-type="method" id="engine-tokenGetAll-nav"><a href="engine.html#tokenGetAll">tokenGetAll</a></li></ul></li><li id="Entry-nav"><a href="Entry.html">Entry</a></li><li id="Error-nav"><a href="Error.html">Error</a></li><li id="Eval-nav"><a href="Eval.html">Eval</a></li><li id="Exit-nav"><a href="Exit.html">Exit</a></li><li id="Expression-nav"><a href="Expression.html">Expression</a></li><li id="For-nav"><a href="For.html">For</a></li><li id="Foreach-nav"><a href="Foreach.html">Foreach</a></li><li id="Function-nav"><a href="Function.html">Function</a><ul class='methods'><li data-type="method" id="Function-parseFlags-nav"><a href="Function.html#parseFlags">parseFlags</a></li></ul></li><li id="Global-nav"><a href="Global_.html">Global</a></li><li id="Goto-nav"><a href="Goto.html">Goto</a></li><li id="Halt-nav"><a href="Halt.html">Halt</a></li><li id="Identifier-nav"><a href="Identifier.html">Identifier</a></li><li id="If-nav"><a href="If.html">If</a></li><li id="Include-nav"><a href="Include.html">Include</a></li><li id="Inline-nav"><a href="Inline.html">Inline</a></li><li id="Interface-nav"><a href="Interface.html">Interface</a><ul class='methods'><li data-type="method" id="Interface-parseFlags-nav"><a href="Interface.html#parseFlags">parseFlags</a></li></ul></li><li id="Isset-nav"><a href="Isset.html">Isset</a></li><li id="Label-nav"><a href="Label.html">Label</a></li><li id="lexer-nav"><a href="lexer.html">lexer</a><ul class='methods'><li data-type="method" id="lexer-getState-nav"><a href="lexer.html#getState">getState</a></li><li data-type="method" id="lexer-input-nav"><a href="lexer.html#input">input</a></li><li data-type="method" id="lexer-setInput-nav"><a href="lexer.html#setInput">setInput</a></li><li data-type="method" id="lexer-setState-nav"><a href="lexer.html#setState">setState</a></li><li data-type="method" id="lexer-unput-nav"><a href="lexer.html#unput">unput</a></li></ul></li><li id="List-nav"><a href="List.html">List</a></li><li id="Literal-nav"><a href="Literal.html">Literal</a></li><li id="Location-nav"><a href="Location.html">Location</a></li><li id="Lookup-nav"><a href="Lookup.html">Lookup</a></li><li id="Magic-nav"><a href="Magic.html">Magic</a></li><li id="Method-nav"><a href="Method.html">Method</a><ul class='methods'><li data-type="method" id="Method-parseFlags-nav"><a href="Method.html#parseFlags">parseFlags</a></li></ul></li><li id="Namespace-nav"><a href="Namespace.html">Namespace</a></li><li id="New-nav"><a href="New.html">New</a></li><li id="Node-nav"><a href="Node.html">Node</a><ul class='methods'><li data-type="method" id="Node-extends-nav"><a href="Node.html#.extends">extends</a></li></ul></li><li id="Number-nav"><a href="Number.html">Number</a></li><li id="OffsetLookup-nav"><a href="OffsetLookup.html">OffsetLookup</a></li><li id="Operation-nav"><a href="Operation.html">Operation</a></li><li id="Parameter-nav"><a href="Parameter.html">Parameter</a><ul class='methods'><li data-type="method" id="Parameter-parseFlags-nav"><a href="Parameter.html#parseFlags">parseFlags</a></li></ul></li><li id="Parenthesis-nav"><a href="Parenthesis.html">Parenthesis</a></li><li id="parser-nav"><a href="parser.html">parser</a><ul class='methods'><li data-type="method" id="parser-error-nav"><a href="parser.html#error">error</a></li><li data-type="method" id="parser-expect-nav"><a href="parser.html#expect">expect</a></li><li data-type="method" id="parser-expectEndOfStatement-nav"><a href="parser.html#expectEndOfStatement">expectEndOfStatement</a></li><li data-type="method" id="parser-getTokenName-nav"><a href="parser.html#getTokenName">getTokenName</a></li><li data-type="method" id="parser-is-nav"><a href="parser.html#is">is</a></li><li data-type="method" id="parser-lex-nav"><a href="parser.html#lex">lex</a></li><li data-type="method" id="parser-next-nav"><a href="parser.html#next">next</a></li><li data-type="method" id="parser-node-nav"><a href="parser.html#node">node</a></li><li data-type="method" id="parser-parse-nav"><a href="parser.html#parse">parse</a></li><li data-type="method" id="parser-raiseError-nav"><a href="parser.html#raiseError">raiseError</a></li><li data-type="method" id="parser-text-nav"><a href="parser.html#text">text</a></li></ul></li><li id="Position-nav"><a href="Position.html">Position</a></li><li id="Post-nav"><a href="Post.html">Post</a></li><li id="Pre-nav"><a href="Pre.html">Pre</a></li><li id="Print-nav"><a href="Print.html">Print</a></li><li id="Program-nav"><a href="Program.html">Program</a></li><li id="Property-nav"><a href="Property.html">Property</a><ul class='methods'><li data-type="method" id="Property-parseFlags-nav"><a href="Property.html#parseFlags">parseFlags</a></li></ul></li><li id="PropertyLookup-nav"><a href="PropertyLookup.html">PropertyLookup</a></li><li id="RetIf-nav"><a href="RetIf.html">RetIf</a></li><li id="Return-nav"><a href="Return.html">Return</a></li><li id="Silent-nav"><a href="Silent.html">Silent</a></li><li id="Statement-nav"><a href="Statement.html">Statement</a></li><li id="Static-nav"><a href="Static.html">Static</a></li><li id="StaticLookup-nav"><a href="StaticLookup.html">StaticLookup</a></li><li id="String-nav"><a href="String.html">String</a></li><li id="Switch-nav"><a href="Switch.html">Switch</a></li><li id="Sys-nav"><a href="Sys.html">Sys</a></li><li id="Throw-nav"><a href="Throw.html">Throw</a></li><li id="Trait-nav"><a href="Trait.html">Trait</a><ul class='methods'><li data-type="method" id="Trait-parseFlags-nav"><a href="Trait.html#parseFlags">parseFlags</a></li></ul></li><li id="TraitAlias-nav"><a href="TraitAlias.html">TraitAlias</a></li><li id="TraitPrecedence-nav"><a href="TraitPrecedence.html">TraitPrecedence</a></li><li id="TraitUse-nav"><a href="TraitUse.html">TraitUse</a></li><li id="Try-nav"><a href="Try.html">Try</a></li><li id="Unary-nav"><a href="Unary.html">Unary</a></li><li id="Unset-nav"><a href="Unset.html">Unset</a></li><li id="UseGroup-nav"><a href="UseGroup.html">UseGroup</a></li><li id="UseItem-nav"><a href="UseItem.html">UseItem</a></li><li id="Variable-nav"><a href="Variable.html">Variable</a></li><li id="variadic-nav"><a href="variadic.html">variadic</a></li><li id="While-nav"><a href="While.html">While</a></li><li id="Yield-nav"><a href="Yield.html">Yield</a></li><li id="YieldFrom-nav"><a href="YieldFrom.html">YieldFrom</a></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#FULL_QUALIFIED_NAME">FULL_QUALIFIED_NAME</a></li><li><a href="global.html#getStringBuffer">getStringBuffer</a></li><li><a href="global.html#ignoreStack">ignoreStack</a></li><li><a href="global.html#MODE_BLOCK">MODE_BLOCK</a></li><li><a href="global.html#MODE_NONE">MODE_NONE</a></li><li><a href="global.html#MODE_SHORT">MODE_SHORT</a></li><li><a href="global.html#QUALIFIED_NAME">QUALIFIED_NAME</a></li><li><a href="global.html#RELATIVE_NAME">RELATIVE_NAME</a></li><li><a href="global.html#TYPE_CONST">TYPE_CONST</a></li><li><a href="global.html#TYPE_FUNC">TYPE_FUNC</a></li><li><a href="global.html#TYPE_HEREDOC">TYPE_HEREDOC</a></li><li><a href="global.html#TYPE_OFFSET">TYPE_OFFSET</a></li><li><a href="global.html#TYPE_SHELL">TYPE_SHELL</a></li><li><a href="global.html#TYPE_STRING">TYPE_STRING</a></li><li><a href="global.html#UNQUALIFIED_NAME">UNQUALIFIED_NAME</a></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        lexer.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>/**
 * Copyright (C) 2018 Glayzzle (BSD3 License)
 * @authors https://github.com/glayzzle/php-parser/graphs/contributors
 * @url http://glayzzle.com
 */
"use strict";

/**
 * This is the php lexer. It will tokenize the string for helping the
 * parser to build the AST from its grammar.
 *
 * @class
 * @property {Integer} EOF
 * @property {Boolean} all_tokens defines if all tokens must be retrieved (used by token_get_all only)
 * @property {Boolean} comment_tokens extracts comments tokens
 * @property {Boolean} mode_eval enables the evald mode (ignore opening tags)
 * @property {Boolean} asp_tags disables by default asp tags mode
 * @property {Boolean} short_tags enables by default short tags mode
 * @property {Object} keywords List of php keyword
 * @property {Object} castKeywords List of php keywords for type casting
 */
const lexer = function(engine) {
  this.engine = engine;
  this.tok = this.engine.tokens.names;
  this.EOF = 1;
  this.debug = false;
  this.all_tokens = true;
  this.comment_tokens = false;
  this.mode_eval = false;
  this.asp_tags = false;
  this.short_tags = true;
  this.php7 = true;
  this.yyprevcol = 0;
  this.keywords = {
    __class__: this.tok.T_CLASS_C,
    __trait__: this.tok.T_TRAIT_C,
    __function__: this.tok.T_FUNC_C,
    __method__: this.tok.T_METHOD_C,
    __line__: this.tok.T_LINE,
    __file__: this.tok.T_FILE,
    __dir__: this.tok.T_DIR,
    __namespace__: this.tok.T_NS_C,
    exit: this.tok.T_EXIT,
    die: this.tok.T_EXIT,
    function: this.tok.T_FUNCTION,
    const: this.tok.T_CONST,
    return: this.tok.T_RETURN,
    try: this.tok.T_TRY,
    catch: this.tok.T_CATCH,
    finally: this.tok.T_FINALLY,
    throw: this.tok.T_THROW,
    if: this.tok.T_IF,
    elseif: this.tok.T_ELSEIF,
    endif: this.tok.T_ENDIF,
    else: this.tok.T_ELSE,
    while: this.tok.T_WHILE,
    endwhile: this.tok.T_ENDWHILE,
    do: this.tok.T_DO,
    for: this.tok.T_FOR,
    endfor: this.tok.T_ENDFOR,
    foreach: this.tok.T_FOREACH,
    endforeach: this.tok.T_ENDFOREACH,
    declare: this.tok.T_DECLARE,
    enddeclare: this.tok.T_ENDDECLARE,
    instanceof: this.tok.T_INSTANCEOF,
    as: this.tok.T_AS,
    switch: this.tok.T_SWITCH,
    endswitch: this.tok.T_ENDSWITCH,
    case: this.tok.T_CASE,
    default: this.tok.T_DEFAULT,
    break: this.tok.T_BREAK,
    continue: this.tok.T_CONTINUE,
    goto: this.tok.T_GOTO,
    echo: this.tok.T_ECHO,
    print: this.tok.T_PRINT,
    class: this.tok.T_CLASS,
    interface: this.tok.T_INTERFACE,
    trait: this.tok.T_TRAIT,
    extends: this.tok.T_EXTENDS,
    implements: this.tok.T_IMPLEMENTS,
    new: this.tok.T_NEW,
    clone: this.tok.T_CLONE,
    var: this.tok.T_VAR,
    eval: this.tok.T_EVAL,
    include: this.tok.T_INCLUDE,
    include_once: this.tok.T_INCLUDE_ONCE,
    require: this.tok.T_REQUIRE,
    require_once: this.tok.T_REQUIRE_ONCE,
    namespace: this.tok.T_NAMESPACE,
    use: this.tok.T_USE,
    insteadof: this.tok.T_INSTEADOF,
    global: this.tok.T_GLOBAL,
    isset: this.tok.T_ISSET,
    empty: this.tok.T_EMPTY,
    __halt_compiler: this.tok.T_HALT_COMPILER,
    static: this.tok.T_STATIC,
    abstract: this.tok.T_ABSTRACT,
    final: this.tok.T_FINAL,
    private: this.tok.T_PRIVATE,
    protected: this.tok.T_PROTECTED,
    public: this.tok.T_PUBLIC,
    unset: this.tok.T_UNSET,
    list: this.tok.T_LIST,
    array: this.tok.T_ARRAY,
    callable: this.tok.T_CALLABLE,
    or: this.tok.T_LOGICAL_OR,
    and: this.tok.T_LOGICAL_AND,
    xor: this.tok.T_LOGICAL_XOR
  };
  this.castKeywords = {
    int: this.tok.T_INT_CAST,
    integer: this.tok.T_INT_CAST,
    real: this.tok.T_DOUBLE_CAST,
    double: this.tok.T_DOUBLE_CAST,
    float: this.tok.T_DOUBLE_CAST,
    string: this.tok.T_STRING_CAST,
    binary: this.tok.T_STRING_CAST,
    array: this.tok.T_ARRAY_CAST,
    object: this.tok.T_OBJECT_CAST,
    bool: this.tok.T_BOOL_CAST,
    boolean: this.tok.T_BOOL_CAST,
    unset: this.tok.T_UNSET_CAST
  };
};

/**
 * Initialize the lexer with the specified input
 */
lexer.prototype.setInput = function(input) {
  this._input = input;
  this.size = input.length;
  this.yylineno = 1;
  this.offset = 0;
  this.yyprevcol = 0;
  this.yytext = "";
  this.yylloc = {
    first_offset: 0,
    first_line: 1,
    first_column: 0,
    prev_offset: 0,
    prev_line: 1,
    prev_column: 0,
    last_line: 1,
    last_column: 0
  };
  this.tokens = [];
  this.done = this.offset >= this.size;
  if (!this.all_tokens &amp;&amp; this.mode_eval) {
    this.conditionStack = ["INITIAL"];
    this.begin("ST_IN_SCRIPTING");
  } else {
    this.conditionStack = [];
    this.begin("INITIAL");
  }
  return this;
};

/**
 * consumes and returns one char from the input
 */
lexer.prototype.input = function() {
  const ch = this._input[this.offset];
  if (!ch) return "";
  this.yytext += ch;
  this.offset++;
  if (ch === "\r" &amp;&amp; this._input[this.offset] === "\n") {
    this.yytext += "\n";
    this.offset++;
  }
  if (ch === "\n" || ch === "\r") {
    this.yylloc.last_line = ++this.yylineno;
    this.yyprevcol = this.yylloc.last_column;
    this.yylloc.last_column = 0;
  } else {
    this.yylloc.last_column++;
  }
  return ch;
};

/**
 * revert eating specified size
 */
lexer.prototype.unput = function(size) {
  if (size === 1) {
    // 1 char unput (most cases)
    this.offset--;
    if (
      this._input[this.offset] === "\n" &amp;&amp;
      this._input[this.offset - 1] === "\r"
    ) {
      this.offset--;
      size++;
    }
    if (
      this._input[this.offset] === "\r" ||
      this._input[this.offset] === "\n"
    ) {
      this.yylloc.last_line--;
      this.yylineno--;
      this.yylloc.last_column = this.yyprevcol;
    } else {
      this.yylloc.last_column--;
    }
    this.yytext = this.yytext.substring(0, this.yytext.length - size);
  } else if (size > 0) {
    this.offset -= size;
    if (size &lt; this.yytext.length) {
      this.yytext = this.yytext.substring(0, this.yytext.length - size);
      // re-calculate position
      this.yylloc.last_line = this.yylloc.first_line;
      this.yylloc.last_column = this.yyprevcol = this.yylloc.first_column;
      for (let i = 0; i &lt; this.yytext.length; i++) {
        let c = this.yytext[i];
        if (c === "\r") {
          c = this.yytext[++i];
          this.yyprevcol = this.yylloc.last_column;
          this.yylloc.last_line++;
          this.yylloc.last_column = 0;
          if (c !== "\n") {
            if (c === "\r") {
              this.yylloc.last_line++;
            } else {
              this.yylloc.last_column++;
            }
          }
        } else if (c === "\n") {
          this.yyprevcol = this.yylloc.last_column;
          this.yylloc.last_line++;
          this.yylloc.last_column = 0;
        } else {
          this.yylloc.last_column++;
        }
      }
      this.yylineno = this.yylloc.last_line;
    } else {
      // reset full text
      this.yytext = "";
      this.yylloc.last_line = this.yylineno = this.yylloc.first_line;
      this.yylloc.last_column = this.yylloc.first_column;
    }
  }

  return this;
};

// check if the text matches
lexer.prototype.tryMatch = function(text) {
  return text === this.ahead(text.length);
};

// check if the text matches
lexer.prototype.tryMatchCaseless = function(text) {
  return text === this.ahead(text.length).toLowerCase();
};

// look ahead
lexer.prototype.ahead = function(size) {
  let text = this._input.substring(this.offset, this.offset + size);
  if (
    text[text.length - 1] === "\r" &amp;&amp;
    this._input[this.offset + size + 1] === "\n"
  ) {
    text += "\n";
  }
  return text;
};

// consume the specified size
lexer.prototype.consume = function(size) {
  for (let i = 0; i &lt; size; i++) {
    const ch = this._input[this.offset];
    if (!ch) break;
    this.yytext += ch;
    this.offset++;
    if (ch === "\r" &amp;&amp; this._input[this.offset] === "\n") {
      this.yytext += "\n";
      this.offset++;
      i++;
    }
    if (ch === "\n" || ch === "\r") {
      this.yylloc.last_line = ++this.yylineno;
      this.yyprevcol = this.yylloc.last_column;
      this.yylloc.last_column = 0;
    } else {
      this.yylloc.last_column++;
    }
  }
  return this;
};

/**
 * Gets the current state
 */
lexer.prototype.getState = function() {
  return {
    yytext: this.yytext,
    offset: this.offset,
    yylineno: this.yylineno,
    yyprevcol: this.yyprevcol,
    yylloc: {
      first_offset: this.yylloc.first_offset,
      first_line: this.yylloc.first_line,
      first_column: this.yylloc.first_column,
      last_line: this.yylloc.last_line,
      last_column: this.yylloc.last_column
    }
  };
};

/**
 * Sets the current lexer state
 */
lexer.prototype.setState = function(state) {
  this.yytext = state.yytext;
  this.offset = state.offset;
  this.yylineno = state.yylineno;
  this.yyprevcol = state.yyprevcol;
  this.yylloc = state.yylloc;
  return this;
};

// prepend next token
lexer.prototype.appendToken = function(value, ahead) {
  this.tokens.push([value, ahead]);
  return this;
};

// return next match that has a token
lexer.prototype.lex = function() {
  this.yylloc.prev_offset = this.offset;
  this.yylloc.prev_line = this.yylloc.last_line;
  this.yylloc.prev_column = this.yylloc.last_column;
  let token = this.next() || this.lex();
  if (!this.all_tokens) {
    while (
      token === this.tok.T_WHITESPACE || // ignore white space
      (!this.comment_tokens &amp;&amp;
        (token === this.tok.T_COMMENT || // ignore single lines comments
          token === this.tok.T_DOC_COMMENT)) || // ignore doc comments
      // ignore open tags
      token === this.tok.T_OPEN_TAG
    ) {
      token = this.next() || this.lex();
    }
    if (token == this.tok.T_OPEN_TAG_WITH_ECHO) {
      // https://github.com/php/php-src/blob/7ff186434e82ee7be7c59d0db9a976641cf7b09c/Zend/zend_compile.c#L1683
      // open tag with echo statement
      return this.tok.T_ECHO;
    } else if (token === this.tok.T_CLOSE_TAG) {
      // https://github.com/php/php-src/blob/7ff186434e82ee7be7c59d0db9a976641cf7b09c/Zend/zend_compile.c#L1680
      return ";"; /* implicit ; */
    }
  }
  if (!this.yylloc.prev_offset) {
    this.yylloc.prev_offset = this.yylloc.first_offset;
    this.yylloc.prev_line = this.yylloc.first_line;
    this.yylloc.prev_column = this.yylloc.first_column;
  }
  /*else if (this.yylloc.prev_offset === this.offset &amp;&amp; this.offset !== this.size) {
    throw new Error('Infinite loop @ ' + this.offset + ' / ' + this.size);
  }*/
  return token;
};

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
lexer.prototype.begin = function(condition) {
  this.conditionStack.push(condition);
  this.curCondition = condition;
  this.stateCb = this["match" + condition];
  if (typeof this.stateCb !== "function") {
    throw new Error('Undefined condition state "' + condition + '"');
  }
  return this;
};

// pop the previously active lexer condition state off the condition stack
lexer.prototype.popState = function() {
  const n = this.conditionStack.length - 1;
  const condition = n > 0 ? this.conditionStack.pop() : this.conditionStack[0];
  this.curCondition = this.conditionStack[this.conditionStack.length - 1];
  this.stateCb = this["match" + this.curCondition];
  if (typeof this.stateCb !== "function") {
    throw new Error('Undefined condition state "' + this.curCondition + '"');
  }
  return condition;
};

// return next match in input
lexer.prototype.next = function() {
  let token;
  if (!this._input) {
    this.done = true;
  }
  this.yylloc.first_offset = this.offset;
  this.yylloc.first_line = this.yylloc.last_line;
  this.yylloc.first_column = this.yylloc.last_column;
  this.yytext = "";
  if (this.done) {
    this.yylloc.prev_offset = this.yylloc.first_offset;
    this.yylloc.prev_line = this.yylloc.first_line;
    this.yylloc.prev_column = this.yylloc.first_column;
    return this.EOF;
  }
  if (this.tokens.length > 0) {
    token = this.tokens.shift();
    if (typeof token[1] === "object") {
      this.setState(token[1]);
    } else {
      this.consume(token[1]);
    }
    token = token[0];
  } else {
    token = this.stateCb.apply(this, []);
  }
  if (this.offset >= this.size &amp;&amp; this.tokens.length === 0) {
    this.done = true;
  }
  if (this.debug) {
    let tName = token;
    if (typeof tName === "number") {
      tName = this.engine.tokens.values[tName];
    } else {
      tName = '"' + tName + '"';
    }
    const e = new Error(
      tName +
        "\tfrom " +
        this.yylloc.first_line +
        "," +
        this.yylloc.first_column +
        "\t - to " +
        this.yylloc.last_line +
        "," +
        this.yylloc.last_column +
        '\t"' +
        this.yytext +
        '"'
    );
    // eslint-disable-next-line no-console
    console.error(e.stack);
  }
  return token;
};

// extends the lexer with states
[
  require("./lexer/comments.js"),
  require("./lexer/initial.js"),
  require("./lexer/numbers.js"),
  require("./lexer/property.js"),
  require("./lexer/scripting.js"),
  require("./lexer/strings.js"),
  require("./lexer/tokens.js"),
  require("./lexer/utils.js")
].forEach(function(ext) {
  for (const k in ext) {
    lexer.prototype[k] = ext[k];
  }
});

module.exports = lexer;
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  
  
</body>
</html>
